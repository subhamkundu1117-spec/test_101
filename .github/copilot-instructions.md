## Purpose

This repository contains small prebuilt example binaries (macOS) and debug symbols. This document gives concise, actionable instructions an AI coding agent or new contributor needs to be productive: how to run what's here, how to build if source is added, and project-specific conventions.

## Big picture (what you'll find)
- Top-level binaries: `helloworld`, `prog 2`, `program 3` (these are compiled executables, not source).
- macOS debug symbols folder: `helloworld.dSYM/` (indicates the artifacts were built on macOS, likely with clang/clang++).
- There is no source directory or .c/.cpp files in the repository root currently. If you add source, follow the short build conventions below.

## How to run (quick)
- Ensure the binary is executable, then run from the repo root:

  - Make executable (if needed):

    chmod +x ./helloworld

  - Run (no spaces):

    ./helloworld

  - Run a filename that contains spaces (escape or quote):

    ./program\ 3
    # or
    ./"program 3"

  - If a binary fails to run, inspect file type:

    file ./helloworld

## How to build (if you add source)

This repository was produced on macOS and is compatible with clang/clang++. The workspace contains a VS Code build task that compiles the active file with clang++.

- Minimal C example (if you create `src/hello.c`):

  clang -g -O0 src/hello.c -o helloworld

- Minimal C++ example (if you create `src/main.cpp`):

  clang++ -fcolor-diagnostics -fansi-escape-codes -g src/main.cpp -o main

- Use the included VS Code task (auto-generated by the C++ extension):

  - Task label: `C/C++: clang++ build active file`
  - Behavior: compiles the currently active file with `-g` and writes the binary next to the source.
  - Invoke via the Command Palette: `Tasks: Run Build Task` or use the UI Run/Build commands.

Conventions when adding source:
- Prefer placing new source under `src/` and keep binaries out of version control where possible.
- Avoid spaces in file names and binary names for ease of scripting (the repo currently contains spaces; be explicit about escaping).

## Debugging
- Use lldb for native debugging on macOS:

  lldb ./helloworld

- The `helloworld.dSYM/` folder contains debug symbol information; keep it if you want meaningful stack traces on macOS.

## Project-specific patterns and gotchas
- The repository currently stores compiled artifacts (binaries + `.dSYM`). There are no build scripts (Makefile/CMake) or package manifests. If you add a build system, put it at the repo root and document it here.
- Filenames with spaces are present (`prog 2`, `program 3`). Automation should either quote paths or normalize names.
- No automated tests or CI are present (no `.github/workflows/`), so changes should be smoke-tested locally.

## Example quick workflow
1. Run an existing binary:

   chmod +x ./helloworld && ./helloworld

2. Add a quick C++ file at `src/main.cpp`, build and run:

   clang++ -g src/main.cpp -o bin/main
   ./bin/main

3. Debug with lldb if you need a breakpoint:

   lldb -- ./bin/main

## Where to update this doc
- If you add source files, build scripts (Makefile/CMake), CI, or a different target OS, update this file to reflect the new developer workflows.

---
If any of the above is unclear or you want me to add example source + a Makefile/CMakeLists and a simple README, tell me which language (C or C++) and I will scaffold it.
